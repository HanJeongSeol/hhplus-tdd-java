### 동시성 제어 방식 분석 및 보고서

---

#### 1. **동시성 문제란?**

동시성 문제는 여러 스레드가 동시에 같은 자원에 접근하여 읽거나 수정할 때 발생하는 문제를 말한다.
이로 인해 데이터 손실, 불일치 등의 문제가 발생할 수 있다.
이번 과제에서는 포인트 충전 및 소모 작업이 동시에 이루어질 때 문제가 발생할 가능성이 있다.
예를 들어, 한 사용자가 충전과 소모 요청을 빠르게 여러 번 보낸다고 가정했을 때,
충전이 완료되기 전에 소모가 처리되면 포인트가 음수로 떨어질 위험이 있다.
이를 방지하기 위해 동기화 제어가 필요하다.

---

#### 2. **해결 방식**
동시성 문제를 해결하기 위해 다음과 같은 방식에 대해서 조사했다.

- **Synchronized**:
    - 자바에서 기본적으로 제공하는 동기화 키워드다.
    - 특정 코드 블록이나 메서드를 한 번에 하나의 스레드만 실행하도록 설정한다.
    - 예시로, 한 사용자가 포인트 충전 요청을 하면, 다른 사용자는 앞 사람의 충전이 끝날 때 까지 기다려야 한다.

- **ConcurrentHashMap**:
    - 자바에서 제공하는 동시성을 고려한 컬렉션 클래스다.
    - 다수의 스레드가 동시에 데이터를 읽고 수정해도 안정성을 보장한다.
    - Map 자료구조를 활용한다.

- **ReentrantLock**:
    - 자바에서 제공하는 Lock 인터페이스를 구현한 클래스다.
    - 공정성을 설정해 스레드가 순서대로 자원에 접근하도록 할 수 있다.

---

#### 3. **구현 시 ReentrantLock를 사용한 이유**
동시성 문제를 해결하기 위해 여러 방법을 찾아봤지만, 이번 과제에서는 **ReentrantLock**을 사용했다.
1. Synchronized의 문제점
      - Synchronized는 **LIFO(Last In, First Out)** 방식으로 작동하기 때문에 문제가 발생할 수 있다.
      - 가장 마지막에 락을 요청한 스레드가 먼저 작업을 시작하게 된다면 대기 시간이 긴 스레드는 계속 대기해야하는 문제가 발생한다.
      - 공정성을 고려한, 즉 순차 처리 작업이 중요한 이번 과제에는 적합하지 않다.
2. ConcurrentHashMap의 한계
      - 멘토링 청강에서 **ConcurrentHashMap**은 특정한 작업 순서를 완벽하게 보장하지 않는다는 것을 알게되었다.
      - **ConcurrentHashMap**은 Map 구조로서 데이터의 동시 접근을 안전하게 관리할 수는 있지만 이번 과제에 중요한 점은 순차 처리였기 때문에 적합하지 않다.
3. **ReentrantLock**을 선택한 이유
    - **ReentrantLock**은 **FIFO(First In, First Out)** 방식으로 락의 순서를 관리할 수 있다. 
    - 공정성 모드를 활성화하면, 요청이 들어온 순서대로 작업을 처리하기 때문에 순차 처리를 보장할 수 있다.
---

#### 4. **결론**
이번 과제에서는 순차 처리가 중요한 요구사항이었기 때문에 **ReentrantLock**을 활용하여 공정성을 보장하여 동시성 문제를 해결했다.
동시성 제어는 서비스를 제공하는 프로젝트에서 반드시 고려해야 할 필수 요소다. 
따라서, 동시성 제어에 관련된 새로운 키워드와 클래스들을 추가로 학습하여 앞으로 다양한 요구사항에 맞는 동시성 제어 기능을 설계하고 구현할 수 있도록 준비해야 한다.
